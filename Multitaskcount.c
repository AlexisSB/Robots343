#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "moveLibrary.c"

int tiles = 0;
int blackThreshold = 15;
int whiteThreshold = 50;
int testcolor = SensorValue[colorSensor];
bool isGrey(){

return (SensorValue(colorSensor) > blackThreshold && SensorValue(colorSensor) < whiteThreshold);

}

bool isBlackOrWhite(){

return (SensorValue(colorSensor) < blackThreshold || SensorValue(colorSensor) > whiteThreshold);
}


task TileCount{
	bool isTileWhite = false;
	bool isTileBlack = false;


while (tiles<16)
{
	 if(SensorValue[colorSensor] > whiteThreshold)
	 { isTileWhite =true;
		 isTileBlack = false;
	 }else{
	 isTileWhite = false;
	 }

	if (!isTileWhite&&!isTileBlack)
		{
			if(SensorValue(colorSensor) < blackThreshold) {
			isTileBlack = true;
			playSound(soundBlip);
			isTileWhite = false;
			tiles++;
		 }
}
}

}

task LineCorrection{

//to tidy make funciton isBlack, isWhite, isGrey

if (isGrey()){
		moveDistance(2,50);
	if (isGrey()){
		turnClockwise(60);//turns right
		if(isGrey()){
			turnAntiClockwise(120); //if still on grey goes back to left
			if(isBlackOrWhite()){ //rotates left until meets grey again
				while (isBlackOrWhite()){
				turnAntiClockwise(10);
				}
			turnClockwise(90); //corrects to right
			moveDistance(4,50); //goes forward
			turnClockwise(90);// should be back goin straight now.
			}
		}else{ // comes here if it hits white of black going right
		while (isBlackOrWhite()){
				turnAntiClockwise(10);
			}
			turnAntiClockwise(90);
			moveDistance(4,50);
			turnAntiClockwise(90);
			}
	}
}


/*
if on grey
	move forward a little bit
if still on grey correct path
	rotate left if still grey rotate right if white or black rotate untilgrey again then do 90 degrees
		go forward a bit then 90 turn again
*/

}

task keepGoingForward {
	while (tiles<16){
	motor[motorB] = 50;
	motor[motorC] = 50;
}
motor[motorB] = 0;
motor[motorC] = 0;
}

task main {

int count =0;
 // move forward from the start tile
 // do a 90 degree clockwise turn
//	 moveDistance(4,30);
//	 wait1Msec(1000);
//	 turnClockwise(99);//turn angle 99 overshoots to right
//	 wait1Msec(1000);
//startTask (TileCount);
//startTask(keepGoingForward);

while (true){
	if (isBlackOrWhite()){
		moveDistance(10,50);
}else{
	if (isGrey()){
		//suspendTask(keepGoingForward);
		moveDistance(10,50);
		playSound(soundBeepBeep);
		wait1Msec(1000);
		if (isGrey()){
			while (isGrey()){
			turnClockwise(30);//turns right
			count++;
		}
		if (count>2){
			turnClockwise(90);
			moveDistance(4, 50);
			turnClockwise(90);
		}
		else {
			turnAntiClockwise(90);
			moveDistance(4,50);
			turnAntiClockwise(90);
//			if(isGrey()){
//				turnAntiClockwise(120); //if still on grey goes back to left
//				if(isBlackOrWhite()){ //rotates left until meets grey again
//					while (isBlackOrWhite()){
//					turnAntiClockwise(10);
//					}
//				turnClockwise(90); //corrects to right
//				moveDistance(4,50); //goes forward
//				turnClockwise(90);// should be back goin straight now.
				}
//		}else{ // comes here if it hits white of black going right
//			while (isBlackOrWhite()){
//				turnAntiClockwise(10);
//			}
//			turnAntiClockwise(90);
//			moveDistance(4,50);
//			turnAntiClockwise(90);
			}
			}
	}
	//startTask(keepGoingForward);
}


/*


	 // what happens if we hit a grey tile, dun dun dun
	 playSound(soundBeepBeep);
	 wait1Msec(500);
	 setMotorSpeed(motorB, 0);
	 setMotorSpeed(motorC, 0);

	 // turn the robot 90 degrees clockwise
	 turnClockwise(90);

*/
	 // now sonar detection

}
